---
- name: Auditoría Tema 1 - Introducción a GNU/Linux
  hosts: auditadas
  become: no
  gather_facts: no


    # ==========================================================
    # INICIALIZACIÓN
    #
    # Creamos el diccionario "checks" donde iremos guardando
    # el resultado de cada prueba del tema.
    # ==========================================================
  vars:
    tema_id: "tema1"

  tasks:
    - name: Inicializar estructura de resultados
      set_fact:
        checks: {}
      changed_when: false

    # =========================
    # PRUEBA 1 - Sudo instalado
    # Requisito:
    #   - El paquete sudo debe estar instalado
    #
    # Cómo se comprueba:
    #   - dpkg -s sudo
    #     * rc == 0  -> paquete instalado
    #     * rc != 0  -> no instalado
    #
    # CORRECTO si:
    #   - sudo_check.rc == 0
    # =========================
    - name: "[Prueba 1] Comprobar si sudo está instalado"
      command: dpkg -s sudo
      register: sudo_check
      failed_when: false
      changed_when: false

    - name: "[Prueba 1] Guardar resultado"
      set_fact:
        checks: "{{ checks | combine({'1': {'name': 'sudo instalado', 'ok': (sudo_check.rc == 0)}}) }}"
      changed_when: false

    # ======================================
    # PRUEBA 2 - Root no por defecto (shadow)
    #
    # Requisito:
    #   - El usuario root NO debe estar bloqueado
    #   - En /etc/shadow, el campo de contraseña de root:
    #       * no debe ser '!'
    #       * no debe ser '*'
    #
    # Importante:
    #   - Esta prueba REQUIERE permisos de root
    #   - Si sudo NO está instalado, la prueba falla directamente
    #
    # CORRECTO si:
    #   - sudo está instalado
    #   - el campo de contraseña existe
    #   - no empieza por '!' ni '*'
    # ==========================================================
    # ======================================
    - name: "[Prueba 2] Obtener campo de contraseña de root en /etc/shadow (solo si hay sudo)"
      command: "sudo awk -F: '$1==\"root\"{print $2}' /etc/shadow"
      register: root_pwfield
      when: sudo_check.rc == 0
      failed_when: false
      changed_when: false

    - name: "[Prueba 2] Guardar resultado"
      set_fact:
        checks: "{{ checks | combine({'2': {'name': 'root configurado (no bloqueado)', 'ok': (sudo_check.rc == 0) and (((root_pwfield.stdout | default('')) | length) > 0) and not (((root_pwfield.stdout | default('')) is match('^[!*]')) ) }}) }}"
      changed_when: false

    # =========================================
    # PRUEBA 3 - Usuario adminpas en grupo sudo
    # Requisito:
    #   - Existe el usuario adminpas
    #   - adminpas pertenece al grupo sudo
    #
    # No requiere root:
    #   - getent passwd
    #   - getent group
    #
    # CORRECTO si:
    #   - getent passwd adminpas devuelve rc == 0
    #   - adminpas aparece en el grupo sudo
    # =========================================
    - name: "[Prueba 3] Comprobar usuario adminpas"
      command: getent passwd adminpas
      register: admin_user
      failed_when: false
      changed_when: false

    - name: "[Prueba 3] Comprobar grupo sudo"
      command: getent group sudo
      register: sudo_group
      failed_when: false
      changed_when: false

    - name: "[Prueba 3] Guardar resultado"
      set_fact:
        checks: "{{ checks | combine({'3': {'name': 'usuario adminpas existe y está en grupo sudo', 'ok': (admin_user.rc == 0 and 'adminpas' in (sudo_group.stdout | default('')))}}) }}"
      changed_when: false

    # ==========================
    # PRUEBA 4 - Servicio SSH activo
    #
    # Importante:
    #   - No usamos systemctl (no root)
    #   - Se comprueba indirectamente:
    #       * si hay algo escuchando en el puerto 22
    #
    # Comando:
    #   ss -tuln | grep :22
    #
    # CORRECTO si:
    #   - hay algún proceso escuchando en el puerto 22
    # ==========================
    - name: "[Prueba 4] Comprobar si hay algo escuchando en el puerto 22"
      shell: "ss -tuln | grep -qE '(:22\\s)'"
      register: ssh_port
      failed_when: false
      changed_when: false

    - name: "[Prueba 4] Guardar resultado"
      set_fact:
        checks: "{{ checks | combine({'4': {'name': 'servicio SSH activo', 'ok': (ssh_port.rc == 0)}}) }}"
      changed_when: false

    # ==========================================
    # PRUEBA 5 - Sólo terminal (sin entorno gráfico)
    # Requisito:
    #   - NO debe estar instalado Xorg
    #
    # Método (sin root):
    #   - dpkg -s xserver-xorg
    #
    # CORRECTO si:
    #   - xserver-xorg NO está instalado (rc != 0)
    # ==========================================
    - name: "[Prueba 5] Comprobar si hay Xorg instalado"
      command: dpkg -s xserver-xorg
      register: xorg_pkg
      failed_when: false
      changed_when: false

    - name: "[Prueba 5] Guardar resultado"
      set_fact:
        checks: "{{ checks | combine({'5': {'name': 'solo terminal (sin entorno gráfico)', 'ok': (xorg_pkg.rc != 0)}}) }}"
      changed_when: false

    # ==============================
    # PRUEBA 6 - Sistema actualizado
    # Requisito: No debe haber paquetes pendientes de actualizacion
    # Correcto si: no aparecen lineas "upgradable from:" apt list --upgradable 
    # ==============================
    - name: "[Prueba 6] Comprobar actualizaciones pendientes"
      command: apt list --upgradable
      register: updates
      failed_when: false
      changed_when: false

    - name: "[Prueba 6] Guardar resultado"
      set_fact:
        checks: >-
          {{
            checks | combine({
              '6': {
                'name': 'sistema actualizado (sin upgradables)',
                'ok': (
                  (updates.rc | default(1)) == 0
                  and
                  (
                    (updates.stdout | default('') | regex_findall('upgradable from:') | length) == 0
                  )
                )
              }
            })
          }}
      changed_when: false



    # ==========================
    # SCORE FINAL
    # Se calcula el total de pruebas, el numero de pruebas correctas y el porcentaje obtenido
    # ==========================
    - name: Calcular score final
      set_fact:
        total_checks: "{{ checks | length }}"
        passed_checks: "{{ (checks | dict2items | selectattr('value.ok','equalto',true) | list | length) | int }}"
        percent_score: "{{ (( (checks | dict2items | selectattr('value.ok','equalto',true) | list | length) | int ) * 100 / ((checks | length) | int if ((checks | length) | int) > 0 else 1)) | round(0) | int }}"
      changed_when: false

    - name: Mostrar resultados (resumen)
      debug:
        msg:
          - "Tema: {{ tema_id }} Host: {{ inventory_hostname }}"
          - "{% for item in (checks | dict2items | sort(attribute='key')) %}Prueba {{ item.key }} ({{ item.value.name }}): {{ 'CORRECTO' if item.value.ok else 'INCORRECTO' }}{% if not loop.last %}\n{% endif %}{% endfor %}"
          - "SCORE: {{ passed_checks }}/{{ total_checks }} ({{ percent_score }}%)"


      # ==========================
      # EXPORTAR CSV (máquina auditora)
      # Se exportan los resultados a CSV en la maquina auditora usando un script
      # ==========================

    - name: Exportar CSV en la máquina auditora
      import_tasks: /home/tfg-audit/hosts/export_csv.yml
      vars:
        checks: "{{ checks }}"
        passed_checks: "{{ passed_checks }}"
        total_checks: "{{ total_checks }}"
        percent_score: "{{ percent_score }}"
